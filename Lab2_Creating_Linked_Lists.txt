/* DO NOT REMOVE THIS COMMENT!! CSE 3430 lab2.c SP 22 CODE 08032011 */

/* STUDENT NAME: (Marco LoPiccolo) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

	struct Data {
		char title[45];
		char author[40];
		int stockNumber;
		float wholesalePrice;
		float retailPrice;
		int wholesaleQuantity;
		int retailQuantity;
	};

	typedef struct Node {
		struct Data book;
		struct Node *next;
	} Node;

void getDataAndBuildList(Node **listHeadPtr);
Node *createNodeAndGetData(void);
void insertNode(Node **listHeadPtr, Node *newNodePtr);
void deleteNode(Node **listHeadPtr, int prodNumberToDelete);
void getUserOption(Node **listHead);
double calculateTotalRevenue(const Node *listHead);
double calculateInvestmentInInventory(const Node *listHead);
double calculateTotalWholesaleCost(const Node *listHead);
double calculateTotalProfit(const Node *listHead);
int calculateTotalBooksSold(const Node *listHead);
double calculateAverageProfit(const Node *listHead);
void printList(const Node *listHead);
void freeAllNodes(Node **listHeadPtr);

int main() {
	Node *listHead = NULL;
	getDataAndBuildList(&listHead);
	getUserOption(&listHead);
	return 0;
}

void getDataAndBuildList(Node **listHeadPtr) {
	Node *newNodePtr;
	printf("Please enter data about the books.\n\n");
	while (newNodePtr = createNodeAndGetData()) {
		insertNode(listHeadPtr, newNodePtr);
	}
}

Node *createNodeAndGetData(void) {
	Node *newNodePtr;
	newNodePtr = malloc (sizeof(Node));
	if (newNodePtr == NULL) {
		printf("Error: memory could not be allocated for enough nodes. ");
		printf("Terminating program!\n");
		exit (0);
	}
	else {
		scanf("%[^\n]", newNodePtr->book.title);
		if (strcmp(newNodePtr->book.title, "END_DATA") == 0) {
			/* free Node if end of book data detected */
			free(newNodePtr);			
			return NULL;
		}
		else {
			/* consume newline before author string */
			getchar();				
			scanf("%[^\n]s", newNodePtr->book.author);
			scanf("%i", &newNodePtr->book.stockNumber);
			scanf("%f", &newNodePtr->book.wholesalePrice);
			scanf("%f", &newNodePtr->book.retailPrice);
			scanf("%i", &newNodePtr->book.wholesaleQuantity);
			scanf("%i", &newNodePtr->book.retailQuantity);
			/* consume newline before next title string */
			getchar();				
		}
		return newNodePtr;
	}
}

/*Function insert node takes two parameters of a pointer that is pass by reference to allow for the value of the listhead to be changed and the input of the new node which will go through the current list of nodes. It first checks if the nodes list is empty and if it is then it places the first node in there. Any value after the first checks to see what the book stock number of the current node is and the new node being inserted. If it is smaller than the first one in the list, then it just gets put to the front. If the stock number is bigger, then it goes through the entire list checking each stock number to ensure that it is being placed in order based on the stock number. If it is the largest then the list will reach its end and go out of the while loop and at the node to the very end of the list */
void insertNode(Node **listHeadPtr, Node *newNodePtr) {
	Node *traversePtr = *listHeadPtr;

	if (*listHeadPtr == NULL) {
		/* WRITE CODE FOR CASE 1: INSERTION INTO EMPTY LIST */
		*listHeadPtr = newNodePtr;
		newNodePtr->next = NULL;
		printf("Book Stock number %i added to the inventory\n", newNodePtr->book.stockNumber);
		
	}
	else if (newNodePtr->book.stockNumber < traversePtr->book.stockNumber) {
		/* WRITE CODE FOR CASE 2: INSERTION BEFORE CURRENT 1ST NODE */
		newNodePtr->next = *listHeadPtr;
		*listHeadPtr = newNodePtr;
		printf("Book Stock number %i added to the inventory\n", newNodePtr->book.stockNumber);
	}
	else {
		Node *priorNodePtr = traversePtr;
		traversePtr = traversePtr->next;

		while (traversePtr != NULL && newNodePtr->book.stockNumber > traversePtr->book.stockNumber) {
		/* MOVE BOTH POINTERS, IF BOTH CONDITIONS ARE TRUE */
			priorNodePtr = traversePtr;
			traversePtr = traversePtr->next;
		}
	/* Put code to insert Node for case 3 below, after while loop */
	/* above finds Node before which to insert.                  */
		newNodePtr->next = traversePtr;
		priorNodePtr->next = newNodePtr;
		printf("Book Stock number %i added to the inventory\n", newNodePtr->book.stockNumber);

	}		
}

void getUserOption(Node **listHeadPtr) {
	int option;
	Node *newNodePtr;
	int bookNumToDelete;
	do {
		printf("\nPlease enter an integer between 1 and 10 to select an operation on the data:\n");
		scanf("%i", &option);
		getchar();
		switch (option){
			case 1:
				printList (*listHeadPtr);
				break;
			case 2:
				printf("\nTotal revenue: %.2f\n", calculateTotalRevenue(*listHeadPtr));
				break;
			case 3:
				printf("\nTotal wholesale cost: %.2f\n", calculateTotalWholesaleCost(*listHeadPtr));
				break;
			case 4:
				printf("\nTotal investment in inventory: %.2f\n", calculateInvestmentInInventory(*listHeadPtr));
				break;
			case 5:
				printf("\nTotal profit: %.2f\n", calculateTotalProfit(*listHeadPtr)); 
				break;
			case 6:
				printf("\nTotal number of books sold = %i\n", calculateTotalBooksSold(*listHeadPtr));
				break;
			case 7:
				printf("\nAverage profit: %.2f\n", calculateAverageProfit(*listHeadPtr));
				break;
			case 8:		
				printf("\nPlease enter the data for the book you wish to add:\n\n");
				newNodePtr = createNodeAndGetData();
				insertNode(listHeadPtr, newNodePtr);			
				break;
			case 9:
				printf("\nPlease enter the book stock number of the book you wish to delete, ");
				printf("followed by enter.\n");
				scanf("%i", &bookNumToDelete);
				deleteNode(listHeadPtr, bookNumToDelete);
				break;
			case 10:
				freeAllNodes(listHeadPtr);
				break;
			default:
				printf("Valid option choices are 1 to 10. Please choose again!\n");
				break;
		} 
	} while (option != 10);
}

/*Function gets the inputted list head and then it goes through the list using a traverse pointer until the value reaches the end of the list. During this time it adds the retail price times the retailquantity of each book and then returns the revenue summed up*/
double calculateTotalRevenue(const Node *listHead) { 
	double sumRevenue = 0;
	const Node *traversePtr = listHead;
	while (traversePtr != NULL) {		/* determine not at end of list */
		sumRevenue = sumRevenue + traversePtr->book.retailPrice * traversePtr->book.retailQuantity;
		traversePtr = traversePtr->next;
	}
	return sumRevenue;
}

/*Function gets the inputted list head and then it goes through the list using a traverse pointer until the value reaches the end of the list. During this time it finds the difference of wholesale and retail quantity, then multiplies it by the wholesale price then adds it to the summed inventory */
double calculateInvestmentInInventory(const Node *listHead) { 
	double sumInvestmentInventory = 0;
	const Node *traversePtr = listHead;
	while (traversePtr != NULL) {		/* determine not at end of list */
		sumInvestmentInventory = sumInvestmentInventory + ((traversePtr->book.wholesaleQuantity - traversePtr->book.retailQuantity) * traversePtr->book.wholesalePrice);
		traversePtr = traversePtr->next;
	}
	return sumInvestmentInventory;
}

/*Function gets the inputted list head and then it goes through the list using a traverse pointer until the value reaches the end of the list. During this time it adds the wholesale price multiplied by the wholesale quantity for each book then returns all the values summed up.*/
double calculateTotalWholesaleCost(const Node *listHead) { 
	double sumWholeSaleCost = 0;
	const Node *traversePtr = listHead;
	while (traversePtr != NULL) {		/* determine not at end of list */
		sumWholeSaleCost = sumWholeSaleCost + (traversePtr->book.wholesalePrice * traversePtr->book.wholesaleQuantity);
		traversePtr = traversePtr->next;
	}
	return sumWholeSaleCost;
}

/*Function gets the inputted list head and then uses the previously calculated functions to calculate the profit*/
double calculateTotalProfit(const Node *listHead) { 
	double sumProfit = 0;
	const Node *traversePtr = listHead;
	sumProfit = (calculateTotalRevenue(listHead) - calculateTotalWholesaleCost(listHead)) + calculateInvestmentInInventory(listHead);
	return sumProfit;
}

/*Function gets the inputted list head and then it goes through the list using a traverse pointer until the value reaches the end of the list. During this time it adds the retailquantity to get an accurate amount of books sold in total */
int calculateTotalBooksSold(const Node *listHead) { 
	int sumBooksSold = 0;
	const Node *traversePtr = listHead;
	while (traversePtr != NULL) {		/* determine not at end of list */
		sumBooksSold = sumBooksSold + traversePtr->book.retailQuantity;
		traversePtr = traversePtr->next;
	}
	return sumBooksSold;
}

/*Function gets the inputted list head and then uses the previously calculated functions to calculate the average profit by calling the profit function and the total books sold function and then it divides the values and returns a double value of the average profit*/
double calculateAverageProfit(const Node *listHead) {
	double averageProfit = 0;
	averageProfit = calculateTotalProfit(listHead) / calculateTotalBooksSold(listHead);
	
	return averageProfit;
}

/*Function has two input parameters one is the listheadpointer which points to the beginning of the linked list and the desired stock number and book associated to that to be deleted. That is of type integer since the book stock number is an int type in the structure. We create traverse pointer that starts at the beginning of the list using the list head pointer. First we check if there are any values in the list, if there aren't any then we just print an error message. If the stock number desired to be deleted is the first value in the list then we just check to make sure that the first traverse stock number is larger or equal to the desired number, then we delete it by making the new head of the list the following number and freeing the value at the current traverse pointer. Finally we are checking if the value is in the middle of the list or at the end. We check to make sure we aren't at the end of this and if the stock number hasn't been passed yet and then we use the prior node and traverse node to make sure we have a current and previous value saved. Then if the value is in the list then we delete it using the similar method of case 2 by making the next prior pointer the next traverse pointer and then the value that the traverse pointer is on is then freed from the list */
void deleteNode(Node **listHeadPtr, int stockNumToDelete) {
	Node *traversePtr;
	traversePtr = *listHeadPtr;
	if (*listHeadPtr == NULL) {
		/* WRITE CODE FOR CASE 1: DELETION FROM EMPTY LIST */
		printf("ERROR - There are no nodes, so there is nothing to be deleted and the list is empty.\n");
	}
	else if (traversePtr->book.stockNumber >= stockNumToDelete) {
		/* WRITE CODE FOR CASE 2: DELETION OF CURRENT 1ST NODE */
		*listHeadPtr = traversePtr->next;
		free(traversePtr);
		printf("\nBook stock number %i deleted from the inventory\n", stockNumToDelete);
	}
	else {
		Node *priorNodePtr = traversePtr;
		traversePtr = traversePtr->next;

		while (traversePtr != NULL && traversePtr->book.stockNumber > stockNumToDelete) {
		/* MOVE BOTH POINTERS, IF BOTH CONDITIONS ARE TRUE */
			printf("\nWhile loop check");
			priorNodePtr = traversePtr;
			traversePtr = traversePtr->next;
			printf("%i", traversePtr->book.stockNumber);
		}

		/* Print error if end of list reached, or if not, write code */
		/* to delete Node for case 3 below, if Node to delete found,*/
		/* and print message confirming deletion of Node.            */
		if (traversePtr == NULL || traversePtr->book.stockNumber != stockNumToDelete){
			printf("\nERROR: Book stock number %i was not found in the list!\n", stockNumToDelete);
		}
		else {
			priorNodePtr->next = traversePtr->next;
			free(traversePtr);
			printf("\nBook stock number %i deleted from the inventory\n", stockNumToDelete);
		}
	
	}
	/* WRITE THE CODE FOR THIS FUNCTION - SEE COMMENTS BELOW */	

	
		
}

void printList(const Node *listHead) {
	const Node *traversePtr = listHead;
	printf("\nBook list:\n");
	while (traversePtr != NULL) {		/* determine not at end of list */
		printf("%s\n", traversePtr->book.title); 
		traversePtr = traversePtr->next;
	}
	printf("\n");
}

void freeAllNodes(Node **listHeadPtr) {
	Node *traversePtr = *listHeadPtr;
	Node *restOfListPtr = *listHeadPtr;    
	while (restOfListPtr != NULL) {         /* determine list is not empty */
		restOfListPtr = restOfListPtr->next;
		free(traversePtr);
		traversePtr = restOfListPtr;
	}
	*listHeadPtr = NULL; /* set listHeadPtr back to NULL after space freed */
}
